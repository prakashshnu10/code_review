import { stringify } from 'qs';
import { decamelizeKeys } from 'xcase';

// src/RequesterUtils.ts
function formatQuery(params = {}) {
  const decamelized = decamelizeKeys(params);
  return stringify(decamelized, { arrayFormat: "brackets" });
}
function isFormData(object) {
  return typeof object === "object" && object.constructor.name === "FormData";
}
async function defaultOptionsHandler(resourceOptions, {
  body,
  searchParams,
  sudo,
  signal,
  asStream = false,
  method = "get"
} = {}) {
  const { headers: preconfiguredHeaders, authHeaders, url } = resourceOptions;
  const headers = { ...preconfiguredHeaders };
  const defaultOptions = {
    headers,
    method,
    asStream,
    signal,
    prefixUrl: url
  };
  if (sudo)
    defaultOptions.headers.sudo = `${sudo}`;
  if (body) {
    if (isFormData(body)) {
      defaultOptions.body = body;
    } else {
      defaultOptions.body = JSON.stringify(decamelizeKeys(body));
      defaultOptions.headers["content-type"] = "application/json";
    }
  }
  const [authHeaderKey, authHeaderFn] = Object.entries(authHeaders)[0];
  defaultOptions.headers[authHeaderKey] = await authHeaderFn();
  const q = formatQuery(searchParams);
  if (q)
    defaultOptions.searchParams = q;
  return Promise.resolve(defaultOptions);
}
function createRequesterFn(optionsHandler, requestHandler) {
  const methods = ["get", "post", "put", "patch", "delete"];
  return (serviceOptions) => {
    const requester = {};
    methods.forEach((m) => {
      requester[m] = async (endpoint, options) => {
        const requestOptions = await optionsHandler(serviceOptions, { ...options, method: m });
        return requestHandler(endpoint, requestOptions);
      };
    });
    return requester;
  };
}
function extendClass(Base, customConfig = {}) {
  return class extends Base {
    constructor(...options) {
      const [config, ...opts] = options;
      super({ ...customConfig, ...config }, ...opts);
    }
  };
}
function presetResourceArguments(resources, customConfig = {}) {
  const updated = {};
  Object.entries(resources).filter(([, s]) => typeof s === "function").forEach(([k, r]) => {
    updated[k] = extendClass(r, customConfig);
  });
  return updated;
}

// src/BaseResource.ts
function getDynamicToken(tokenArgument) {
  return tokenArgument instanceof Function ? tokenArgument() : Promise.resolve(tokenArgument);
}
var BaseResource = class {
  url;
  requester;
  queryTimeout;
  headers;
  authHeaders;
  camelize;
  rejectUnauthorized;
  constructor({
    sudo,
    profileToken,
    camelize,
    requesterFn,
    profileMode = "execution",
    host = "https://gitlab.com",
    prefixUrl = "",
    rejectUnauthorized = true,
    queryTimeout = 3e5,
    ...tokens
  }) {
    if (!requesterFn)
      throw new ReferenceError("requesterFn must be passed");
    this.url = [host, "api", "v4", prefixUrl].join("/");
    this.headers = {};
    this.authHeaders = {};
    this.rejectUnauthorized = rejectUnauthorized;
    this.camelize = camelize;
    this.queryTimeout = queryTimeout;
    if ("oauthToken" in tokens)
      this.authHeaders.authorization = async () => {
        const token = await getDynamicToken(tokens.oauthToken);
        return `Bearer ${token}`;
      };
    else if ("jobToken" in tokens)
      this.authHeaders["job-token"] = async () => getDynamicToken(tokens.jobToken);
    else if ("token" in tokens)
      this.authHeaders["private-token"] = async () => getDynamicToken(tokens.token);
    else {
      throw new ReferenceError("A token, oauthToken or jobToken must be passed");
    }
    if (profileToken) {
      this.headers["X-Profile-Token"] = profileToken;
      this.headers["X-Profile-Mode"] = profileMode;
    }
    if (sudo)
      this.headers.Sudo = `${sudo}`;
    this.requester = requesterFn({ ...this });
  }
};

export { BaseResource, createRequesterFn, defaultOptionsHandler, formatQuery, presetResourceArguments };
